Only in .: 106changes.patch
--- ./libcxxabi/src/CMakeLists.txt	2025-01-14 02:41:02.000000000 -0700
+++ ./libcxxabi/src/CMakeLists.txt	2025-07-08 10:51:06.000000000 -0600
@@ -219,7 +219,9 @@
   function(export_symbols file)
     # -exported_symbols_list is only available on Apple platforms
     if (APPLE)
-      target_link_libraries(cxxabi_shared PRIVATE "-Wl,-exported_symbols_list,${file}")
+      if (NOT MIN_OSX_VERSION VERSION_LESS "10.7")
+        target_link_libraries(cxxabi_shared PRIVATE "-Wl,-exported_symbols_list,${file}")
+      endif()
     endif()
   endfunction()
 
@@ -227,7 +229,9 @@
     export_symbols("${file}")
     # -reexported_symbols_list is only available on Apple platforms
     if (APPLE)
-      target_link_libraries(cxxabi-reexports INTERFACE "-Wl,-reexported_symbols_list,${file}")
+      if (NOT MIN_OSX_VERSION VERSION_LESS "10.7")
+        target_link_libraries(cxxabi-reexports INTERFACE "-Wl,-reexported_symbols_list,${file}")
+      endif()
     endif()
   endfunction()
 
diff -ur ./compiler-rt/cmake/config-ix.cmake ./compiler-rt/cmake/config-ix.cmake
--- ./compiler-rt/cmake/config-ix.cmake 2025-07-05 16:37:37.000000000 -0600
+++ ./compiler-rt/cmake/config-ix.cmake 2025-01-14 02:41:02.000000000 -0700
@@ -476,11 +476,6 @@
       set(MIN_OSX_VERSION ${DEFAULT_SANITIZER_MIN_OSX_VERSION})
    endif()

-    # Note: In order to target x86_64h on OS X the minimum deployment target must
-    # be 10.8 or higher.
-    if(MIN_OSX_VERSION VERSION_LESS "10.7")
-      message(FATAL_ERROR "macOS deployment target '${SANITIZER_MIN_OSX_VERSION}' is too old.")
-    endif()
   endif()

   set(SANITIZER_MIN_OSX_VERSION "${MIN_OSX_VERSION}" CACHE STRING
diff -ur ./clang/lib/DirectoryWatcher/mac/DirectoryWatcher-mac.cpp ./clang/lib/DirectoryWatcher/mac/DirectoryWatcher-mac.cpp
--- ./clang/lib/DirectoryWatcher/mac/DirectoryWatcher-mac.cpp	2025-07-04 20:35:42.000000000 -0600
+++ ./clang/lib/DirectoryWatcher/mac/DirectoryWatcher-mac.cpp	2025-07-05 07:40:22.000000000 -0600
@@ -98,6 +98,7 @@
 };
 } // namespace
 
+#ifdef ON_LION_OR_LATER
 constexpr const FSEventStreamEventFlags StreamInvalidatingFlags =
     kFSEventStreamEventFlagUserDropped | kFSEventStreamEventFlagKernelDropped |
     kFSEventStreamEventFlagMustScanSubDirs;
@@ -105,6 +106,7 @@
 constexpr const FSEventStreamEventFlags ModifyingFileEvents =
     kFSEventStreamEventFlagItemCreated | kFSEventStreamEventFlagItemRenamed |
     kFSEventStreamEventFlagItemModified;
+#endif
 
 static void eventStreamCallback(ConstFSEventStreamRef Stream,
                                 void *ClientCallBackInfo, size_t NumEvents,
@@ -118,14 +120,26 @@
     StringRef Path = ((const char **)EventPaths)[i];
     const FSEventStreamEventFlags Flags = EventFlags[i];
 
-    if (Flags & StreamInvalidatingFlags) {
+    if (Flags
+#ifdef ON_LION_OR_LATER 
+        & StreamInvalidatingFlags
+#endif 
+        ) {
       Events.emplace_back(DirectoryWatcher::Event{
           DirectoryWatcher::Event::EventKind::WatcherGotInvalidated, ""});
       break;
-    } else if (!(Flags & kFSEventStreamEventFlagItemIsFile)) {
+    } else if (!(Flags
+#ifdef ON_LION_OR_LATER
+          & kFSEventStreamEventFlagItemIsFile
+#endif 
+          )) {
       // Subdirectories aren't supported - if some directory got removed it
       // must've been the watched directory itself.
-      if ((Flags & kFSEventStreamEventFlagItemRemoved) &&
+      if ((Flags
+#ifdef ON_LION_OR_LATER
+            & kFSEventStreamEventFlagItemRemoved
+#endif 
+            ) &&
           Path == ctx->WatchedPath) {
         Events.emplace_back(DirectoryWatcher::Event{
             DirectoryWatcher::Event::EventKind::WatchedDirRemoved, ""});
@@ -135,11 +149,19 @@
       }
       // No support for subdirectories - just ignore everything.
       continue;
-    } else if (Flags & kFSEventStreamEventFlagItemRemoved) {
+    } else if (Flags
+#ifdef ON_LION_OR_LATER
+        & kFSEventStreamEventFlagItemRemoved
+#endif
+        ) {
       Events.emplace_back(DirectoryWatcher::Event::EventKind::Removed,
                           llvm::sys::path::filename(Path));
       continue;
-    } else if (Flags & ModifyingFileEvents) {
+    } else if (Flags
+#ifdef ON_LION_OR_LATER
+        & ModifyingFileEvents
+#endif
+        ) {
       if (!getFileStatus(Path).has_value()) {
         Events.emplace_back(DirectoryWatcher::Event::EventKind::Removed,
                             llvm::sys::path::filename(Path));
@@ -203,7 +225,10 @@
   FSEventStreamRef Result = FSEventStreamCreate(
       nullptr, eventStreamCallback, &Context, PathsToWatch,
       kFSEventStreamEventIdSinceNow, /* latency in seconds */ 0.0,
-      kFSEventStreamCreateFlagFileEvents | kFSEventStreamCreateFlagNoDefer);
+#ifdef ON_LION_OR_LATER
+      kFSEventStreamCreateFlagFileEvents | 
+#endif 
+      kFSEventStreamCreateFlagNoDefer);
   CFRelease(PathsToWatch);
 
   return Result;
@@ -222,7 +247,13 @@
     std::function<void(llvm::ArrayRef<DirectoryWatcher::Event>, bool)> Receiver,
     bool WaitForInitialSync) {
   dispatch_queue_t Queue =
-      dispatch_queue_create("DirectoryWatcher", DISPATCH_QUEUE_SERIAL);
+      dispatch_queue_create("DirectoryWatcher", 
+#ifdef ON_LION_OR_LATER
+          DISPATCH_QUEUE_SERIAL
+#else
+          NULL
+#endif
+          );
 
   if (Path.empty())
     llvm::report_fatal_error(
diff -ur ./compiler-rt/lib/sanitizer_common/sanitizer_mac.cpp ./compiler-rt/lib/sanitizer_common/sanitizer_mac.cpp
--- ./compiler-rt/lib/sanitizer_common/sanitizer_mac.cpp	2025-01-14 02:41:02.000000000 -0700
+++ ./compiler-rt/lib/sanitizer_common/sanitizer_mac.cpp	2025-07-08 11:35:06.000000000 -0600
@@ -71,9 +71,11 @@
 #  include <mach/mach_time.h>
 #  include <mach/vm_statistics.h>
 #  include <malloc/malloc.h>
-#  include <os/log.h>
 #  include <pthread.h>
+#ifndef ON_EL_CAPITAN_OR_LOWER
+#  include <os/log.h>
 #  include <pthread/introspection.h>
+#endif
 #  include <sched.h>
 #  include <signal.h>
 #  include <spawn.h>
@@ -790,9 +792,13 @@
 void WriteOneLineToSyslog(const char *s) {
 #if !SANITIZER_GO
   syslog_lock.CheckLocked();
+#ifndef ON_EL_CAPITAN_OR_LOWER
   if (GetMacosAlignedVersion() >= MacosVersion(10, 12)) {
     os_log_error(OS_LOG_DEFAULT, "%{public}s", s);
   } else {
+#else
+  {
+#endif
     asl_log(nullptr, nullptr, ASL_LEVEL_ERR, "%s", s);
   }
 #endif
@@ -1400,6 +1406,7 @@
   return (u32)sysconf(_SC_NPROCESSORS_ONLN);
 }
 
+#ifndef ON_EL_CAPITAN_OR_LOWER
 void InitializePlatformCommonFlags(CommonFlags *cf) {}
 
 // Pthread introspection hook
@@ -1456,6 +1463,7 @@
   prev_pthread_introspection_hook =
       pthread_introspection_hook_install(&sanitizer_pthread_introspection_hook);
 }
+#endif
 
 }  // namespace __sanitizer
 
diff -ur ./compiler-rt/lib/sanitizer_common/sanitizer_platform.h ./compiler-rt/lib/sanitizer_common/sanitizer_platform.h
--- ./compiler-rt/lib/sanitizer_common/sanitizer_platform.h	2025-01-14 02:41:02.000000000 -0700
+++ ./compiler-rt/lib/sanitizer_common/sanitizer_platform.h	2025-07-05 09:13:03.000000000 -0600
@@ -63,6 +63,9 @@
 //   - SANITIZER_IOSSIM: simulators (iOS and iOS-like)
 //   - SANITIZER_DRIVERKIT
 #if defined(__APPLE__)
+#ifdef ON_BROSEMITE_OR_LOWER 
+#include <uuid/uuid.h>
+#endif
 #  define SANITIZER_APPLE 1
 #  include <TargetConditionals.h>
 #  if TARGET_OS_OSX
Only in ./libcxx/utils/libcxx: __pycache__
diff -ur ./libunwind/src/AddressSpace.hpp ./libunwind/src/AddressSpace.hpp
--- ./libunwind/src/AddressSpace.hpp	2025-01-14 02:41:02.000000000 -0700
+++ ./libunwind/src/AddressSpace.hpp	2025-07-05 08:53:08.000000000 -0600
@@ -56,15 +56,67 @@
 
   struct dyld_unwind_sections
   {
+#ifdef __LP64__
+    const struct mach_header_64* mh;
+#else
     const struct mach_header*   mh;
+#endif
     const void*                 dwarf_section;
+#ifdef __LP64__
+    uint64_t                    dwarf_section_length;
+#else
     uintptr_t                   dwarf_section_length;
+#endif
     const void*                 compact_unwind_section;
+#ifdef __LP64__
+    uint64_t                    compact_unwind_section_length;
+#else
     uintptr_t                   compact_unwind_section_length;
+#endif
   };
 
-  // In 10.7.0 or later, libSystem.dylib implements this function.
-  extern "C" bool _dyld_find_unwind_sections(void *, dyld_unwind_sections *);
+#if (defined(__MAC_OS_X_VERSION_MIN_REQUIRED) \
+    && (__MAC_OS_X_VERSION_MIN_REQUIRED >= 1070)) \
+|| defined(__IPHONE_OS_VERSION_MIN_REQUIRED)
+// In 10.7.0 or later, libSystem.dylib implements this function.
+extern "C" bool _dyld_find_unwind_sections(void *, dyld_unwind_sections *);
+#else
+       #include <mach-o/getsect.h>
+// In 10.6.x and earlier, we need to implement this functionality. Note
+// that this requires a newer version of libmacho (from cctools) than is
+// present in libSystem on 10.6.x (for getsectiondata).
+static inline bool _dyld_find_unwind_sections(void* addr,
+    dyld_unwind_sections* info) {
+  // Find mach-o image containing address.
+  Dl_info dlinfo;
+  if (!dladdr(addr, &dlinfo))
+    return false;
+#if __LP64__
+  const struct mach_header_64 *mh = (const struct mach_header_64 *)dlinfo.dli_fbase;
+  // Initialize the return struct
+  info->mh = (const struct mach_header_64 *)mh;
+  info->dwarf_section = getsectdatafromheader_64(mh, "__TEXT", "__eh_frame", &info->dwarf_section_length);
+  info->compact_unwind_section = getsectdatafromheader_64(mh, "__TEXT", "__unwind_info", &info->compact_unwind_section_length);
+#else
+  const struct mach_header *mh = (const struct mach_header *)dlinfo.dli_fbase;
+  // Initialize the return struct
+  info->mh = (const struct mach_header *)mh;
+  info->dwarf_section = getsectdatafromheader(mh, "__TEXT", "__eh_frame", &info->dwarf_section_length);
+  info->compact_unwind_section = getsectdatafromheader(mh, "__TEXT", "__unwind_info", &info->compact_unwind_section_length);
+#endif
+
+
+  if (!info->dwarf_section) {
+    info->dwarf_section_length = 0;
+  }
+
+  if (!info->compact_unwind_section) {
+    info->compact_unwind_section_length = 0;
+  }
+
+  return true;
+}
+#endif
 
 namespace libunwind {
   bool findDynamicUnwindSections(void *, unw_dynamic_unwind_sections *);
